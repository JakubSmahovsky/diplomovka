/*
  Needham-Schroeder Symmetric Key protocol as described in http://www.lsv.fr/Software/spore/nssk.html
  Following syntax from template instead of usual Tamarin syntax 
*/

theory NSSK
begin

builtins: symmetric-encryption
functions: succ/1

rule Shared_secret:
  [Fr(~K)] --[Neq($X, $Y)]-> [!SK($X, $Y, ~K)]

rule Shared_reveal:
  [!SK(X, Y, K)] --[Reveal(X)]-> [Out(K)] 

rule Shared_reveal2:
  [!SK(X, Y, K)] --[Reveal(Y)]-> [Out(K)]

rule Secret_compromise:
  [Compromitable(X)] --[Compromise(X)]-> [Out(X)]

rule Alice1:
// msg 1: A -> S: <A, B, Na>
  [ Fr(~Na), Fr(~RunID)]
  --[Run('Alice', ~RunID)]-> 
  [ Out(<$A, $B, ~Na>), Alice1(~RunID, $A, $B, ~Na)]

rule Server:
  let
    mb = senc(<~Kab, A>, Kbs)
    ma = senc(<Na, B, ~Kab, mb>, Kas)
  in
// msg 2: S -> A: {Na, B, Kab, {Kab, A}Kbs, Na}Kas
  [ In(<A, B, Na>)
  , !SK(A, $S, Kas)
  , !SK(B, $S, Kbs)
  , Fr(~Kab)]-->
  [ Out(ma)
  , Compromitable(~Kab)]

rule Alice2:
// msg 3: A -> B: {Kab, A}Kbs
  [ In(senc(<Na, B, Kab, mb>, Kas))
  , !SK(A, $S, Kas)
  , Alice1(RunID, A, B, Na)]
  --[Run('Alice', RunID) ]->
  [ Out(mb)
  , Alice2(RunID, A, B, $S, Na, Kas, Kab)]

rule Bob1:
// msg 4: B -> A: {Nb}Kab
  [ In(senc(<Kab, A>, Kbs))
  , !SK($B, $S, Kbs)
  , Fr(~Nb)
  , Fr(~RunID)]
  --[Run('Bob', ~RunID)
  , Id(A)]->
  [ Out(senc(~Nb, Kab))
  , Compromitable(~Nb)
  , Bob1(~RunID, A, $B, $S, ~Nb, Kbs, Kab)]

rule Alice3:
// msg 5: A -> B: {succ(Nb)}Kab
  [ In(senc(Nb, Kab))
  , Alice2(RunID , A, B, S, Na, Kas, Kab)]
  --[Run('Alice', RunID), 
    Alice_done(RunID, A, B, S, Na, Nb, Kas, Kab)]-> 
  [ Out(senc(<succ(Nb)>, Kab))]

rule Bob2:
  [ In(senc(<succ(Nb)>, Kab))
  , Bob1(RunID, A, B, S, Nb, Kbs, Kab)]
  --[Run('Bob', RunID)
  , Bob_done(RunID, A, B, S, Nb, Kbs, Kab)]-> []

restriction Inequality:
  "All x #i. Neq(x,x) @ #i ==> F"

restriction Id_not_pair:
  "All x y #i . Id(<x, y>) @ #i ==> F"

/*assume compromising a secret takes too long to continue the same run with 1 pricipal */
restriction Compromise_timeout:
  "All principal runid secret #i #j #k . 
    Compromise(secret)@#k &
    Run(principal, runid)@#i &
    Run(principal, runid)@#j &
    #i < #k & #k < #j
  ==> F"

lemma executable:
  exists-trace
    "Ex RunID1 RunID2 A B S Na Nb Kas Kbs Kab #i #j.
      Bob_done(RunID1, A, B, S, Nb, Kbs, Kab)@#i &
      Alice_done(RunID2, A, B, S, Na, Nb, Kas, Kab)@#j"

/*
  This lemma does not terminate as an attack under these conditions
  should not exist. I don't yet know if tamarin may terminate and
  prove that the attack is impossible.
  I may come back to this in the future.
*/
lemma authentication:
  all-traces
    "All RunID1 A B S Nb Kbs Kab #i.
      Bob_done(RunID1, A, B, S, Nb, Kbs, Kab)@#i &
      (not Ex #t. Reveal(A)@#t) &
      (not Ex #t. Reveal(B)@#t) &
      (not Ex #t. Reveal(S)@#t)
      ==> 
        Ex RunID2 Na Kas #j. Alice_done(RunID2, A, B, S, Na, Nb, Kas, Kab)@#j &
        #j < #i"
end
