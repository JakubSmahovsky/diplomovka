/* This is an attempt at making a minimal protocol,
where the impostor needs to act as an honest principal at first. */

theory Minimal
begin

builtins: asymmetric-encryption

rule Register_KP:
  let 
    KP = pk(~KS)
  in
  [ Fr(~KS) ] 
  --[Unique(<'Register_PK', $X>)]->
  [ !Ltk($X, ~KS)
  , !Pk($X, KP)
  , Out(KP) ]

rule Register_Alice_and_Charlie:
  [] 
  --[Unique('Alice_and_Charlie')]->
  [ !Alice($A), !Charlie($C)]

/* CHANGE: This time we can have dishonest Bobs, who revealed their public key.*/
rule Reveal_KS:
  [!Ltk( $X, KS)] --[KSReveal($X)]-> [Out(KS)]

/* Alice wants to send her secret to any Bob out there. */
rule Create_secret:
  [ Fr(~s) ] --[Unique('Create_secret')]-> [ !Create_secret(~s) ] 

rule Alice:
  [ !Alice($A)
  , !Create_secret(s)
  , !Pk($B, KPb)] --> 
  [ Out(aenc(s, KPb))]

/* When a Bob gets Alices secret, he sends it to Charlie and wins. */
rule Bob:
  [ In(aenc(s, KPb))
  , !Pk($B, KPb)
  , !Pk($C, KPc) ] 
  --[Bob($B, $C, s) ]->
  [ Out(aenc(<s, 'winner'>, KPc)) ]

/* When Charlie gets the secret, which he knows, he declares the winner. */
rule Charlie:
  [ !Charlie($C)
  , !Create_secret(s)
  , !Pk($C, KPc)
  , In(aenc(<s, 'winner'>, KPc))]
  --[Win($C, s)]-> []

restriction Unique:
  "All x #i #j . Unique(x) @#i & Unique(x) @#j ==> #i = #j"

lemma Executable:
  exists-trace
    " Ex B C s #i #j.
      Win(C, s) @#i &
      Bob(B, C, s) @#j &
      #j < #i
    "

/* Unlucky for actual Bobs, our impostor can be on Alice's list of Bobs and win too */
lemma Bob_allways_wins:
  all-traces
    " All C s #i.
      Win(C, s) @#i
    ==>
      Ex B #j.
      Bob(B, C, s) @#j &
      #j < #i
    "
end

/* CHANGE: This time we can have dishonest Bobs, who revealed their public key. */
    