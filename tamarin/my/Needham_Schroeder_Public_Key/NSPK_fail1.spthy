/*
  Needham-Schroeder Public Key protocol as described in http://www.lsv.fr/Software/spore/nspk.html
  Following syntax from template instead of usual Tamarin syntax 
*/

theory NSPK
begin

builtins: asymmetric-encryption, revealing-signing

rule Register_KP:
  let 
    KP = pk(~KS)
  in
  [ Fr(~KS) ] 
  --[Unique(<'Register_KP', $X>)]->
  [ !Ltk($X, ~KS)
  , !Pk($X, KP)
  , Out(KP) ]

rule Reveal_KS:
  [!Ltk($X, KS)] --[KSReveal($X)]-> [Out(KS)]

rule Announce_Server_Identity:
  [ !Pk($S, KS) ]
  --[Unique('Announce_Server_Identity')]->
  [ !Alice_0($S),
    !Bob_0($S) ]

rule Server:
  [ In(<$X, $Y>)
  , !Pk($Y, KPy)
  , !Ltk($S, KSs)]-->
  [ Out(revealSign(<KPy, $Y>, KSs)) ]

rule Alice_1:
  [ !Alice_0($S) ] -->
  [ Out(<$A, $B>)
  , Alice_1($A, $B, $S)]

rule Alice_2:
  let 
    m = getMessage(ms)
    KPb = fst(m)
    b = snd(m)
  in
  [ Alice_1($A, $B, $S)
  , !Pk($S, KPs)
  , In(ms)
  , Fr(~Na) ]
  --[Eq(revealVerify(ms, m, KPs),true)
  , Eq(b, $B)]-> 
  [ Out(aenc(<~Na, $A>, KPb))
  , Alice_2($A, $B, $S, KPb, ~Na)]

rule Bob_1:
  let 
    m = adec(me, KSb)
    Na = fst(m)
    A = snd(m)
  in
  [ !Bob_0(S)
  , In(me)
  , !Ltk($B, KSb)] -->
  [ Out(<$B, A>)
  , Bob_1(A, $B, S, Na) ]

rule Bob_2:
  let
    m = getMessage(ms)
    KPa = fst(m)
  in
  [ Bob_1(A, $B, $S, Na)
  , !Pk($S, KPs)
  , In(ms)
  , Fr(~Nb) ]
  --[Eq(revealVerify(ms, m, KPs), true)
  , Eq(snd(m), A)]->
  [ Out(aenc(<Na, ~Nb>,KPa))
  , Bob_2(A, $B, $S, KPa, Na, ~Nb)]

rule Alice_3:
  [ Alice_2($A, $B, $S, KPb, Na)
  , !Ltk($A, KSa)
  , In(aenc(<Na, Nb>,KPa))] 
  --[Alice_done($A, $B, $S, KPb, Na, Nb)]->
  [ Out(aenc(Nb, KPb)) ]

rule Bob_3:
  [ Bob_2(A, $B, $S, KPa, Na, Nb)
  , !Ltk($B, KSb)
  , In(aenc(Nb, KPb))]
  --[Bob_done(A, $B, $S, KPa, Na, Nb)]-> []

restriction Equality:
  "All x y #i. Eq(x,y) @#i ==> x = y"

restriction Unique:
  "All x #i #j . Unique(x) @#i & Unique(x) @#j ==> #i = #j"

lemma executable:
  exists-trace
    "Ex A B S KPa KPb Na Nb #i #j.
      Bob_done(A, B, S, KPa, Na, Nb) @#i &
      Alice_done(A, B, S, KPb, Na, Nb) @#j"

lemma authentication:
  all-traces
    "All A B S KPa Na Nb #i .
      Bob_done(A, B, S, KPa, Na, Nb) @#i
    ==>
    (Ex KPb #j.
      Alice_done(A, B, S, KPb, Na, Nb) @#j)
    | (Ex #j .
      KSReveal(A) @#j)
    | (Ex #j .
      KSReveal(B) @#j)
    | (Ex #j .
      KSReveal(S) @#j)
    "

simplify
solve( Bob_2( A, $B, $S, KPa, Na, Nb ) ▶₀ #i )
  case Bob_2
  solve( !Ltk( $B, KSb ) ▶₁ #i )
    case Register_KP
    solve( splitEqs(1) )
      case split_case_1
      solve( splitEqs(2) )
        case split_case_1
        solve( !KU( aenc(~Nb, KPb) ) @ #vk )
          case Alice_3_case_1
          by sorry
        next
          case Alice_3_case_2
          by sorry
        next
          case Bob_1
          by sorry
        next
          case Bob_2
          by sorry
        next
          case c_aenc
          solve( !KU( ~Nb ) @ #vk.3 )
            case Alice_3
            solve( !KU( aenc(<~Na.1, Nb.1>, KPa.1) ) @ #vk.5 )
              case Alice_2
              by contradiction /* forbidden KD-fact */
            next
              case Alice_3_case_1
              by sorry
            next
              case Alice_3_case_2
              by sorry
            next
              case Bob_1
              by sorry
            next
              case Bob_2_case_1
              solve( !KU( aenc(<Na, A>, pk(~KS)) ) @ #vk.4 )
                case Alice_2
                by sorry
              next
                case Alice_3_case_1
                by sorry
              next
                case Alice_3_case_2
                by sorry
              next
                case Bob_1
                by sorry
              next
                case Bob_2_case_1
                by sorry
              next
                case Bob_2_case_2
                by sorry
              next
                case c_aenc
                solve( (#vr.6, 0) ~~> (#vk.1, 0) )
                  case Var_fresh_1_Nb
                  solve( !KU( ~Na ) @ #vk.10 )
                    case Alice_2
                    solve( !KU( revealSign(<KPa, A>, ~KS.1) ) @ #vk.5 )
                      case Alice_3
                      by sorry
                    next
                      case Bob_1
                      by sorry
                    next
                      case Bob_2
                      by sorry
                    next
                      case Server
                      solve( !KU( pk(~KS.1) ) @ #vk.10 )
                        case Alice_3
                        by sorry
                      next
                        case Bob_1
                        by sorry
                      next
                        case Bob_2
                        by sorry
                      next
                        case Register_KP
                        solve( !KU( revealSign(<pk(x), $B.1>, ~KS.2) ) @ #vk.10 )
                          case Alice_3
                          by sorry
                        next
                          case Bob_1
                          by sorry
                        next
                          case Bob_2
                          by sorry
                        next
                          case Server
                          solve( !KU( ~KS.2 ) @ #vk.10 )
                            case Alice_3
                            by sorry
                          next
                            case Bob_1
                            by sorry
                          next
                            case Bob_2
                            by sorry
                          next
                            case Reveal_KS
                            SOLVED // trace found
                          qed
                        next
                          case c_revealSign
                          by sorry
                        qed
                      next
                        case Server
                        by sorry
                      next
                        case c_pk
                        by sorry
                      qed
                    next
                      case c_revealSign
                      by sorry
                    qed
                  next
                    case Alice_3
                    by sorry
                  next
                    case Bob_1
                    by sorry
                  next
                    case Bob_2
                    by sorry
                  qed
                qed
              qed
            next
              case Bob_2_case_2
              by sorry
            next
              case c_aenc
              by contradiction /* cyclic */
            qed
          next
            case Bob_1
            by sorry
          next
            case Bob_2_case_1
            by sorry
          next
            case Bob_2_case_2
            by sorry
          qed
        qed
      next
        case split_case_2
        by sorry
      qed
    next
      case split_case_2
      by sorry
    next
      case split_case_3
      by sorry
    qed
  qed
qed

/* I found a proof manually, however it's not the intended attack.
Neither of the Honest principals seem to be trying to talk to the Impostor,
however they aren't trying to talk to each other either.
Tamarin seems to like doing this. Unless it's necessary,
it won't let honest principals talk to each other
but rather to other "ficticious" principals. */

end