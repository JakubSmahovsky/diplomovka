theory spthy
begin

builtins: symmetric-encryption, hashing

rule init:
[
  Fr(~Kab)
]-->[
  !Bob_init($Bob, ~Kab),
  !Alice_init($Alice, ~Kab)
]

rule Bob_0:
let
  Na = sdec(m1, Kab)
  SuccNa = h(Na)
  m2 = senc(<SuccNa, ~Nb>, Kab)
in
[
  !Bob_init($Bob, Kab),
  In($Alice),
  In(m1),
  Fr(~Nb)
]--[
  Bob_0($Bob, Kab, $Alice, m1, Na, SuccNa, ~Nb, m2)
]->[
  Out(m2),
  Bob_0($Bob, Kab, $Alice, m1, Na, SuccNa, ~Nb, m2)
]

rule Bob_2:
let
  SuccNb = sdec(m3, Kab)
in
[
  Bob_0($Bob, Kab, $Alice, m1, Na, SuccNa, Nb, m2),
  In(m3)
]--[
  Bob_2($Bob, Kab, $Alice, m1, m3, SuccNb),
  Eq(SuccNb, h(Nb))
]->[
  Bob_2($Bob, Kab, $Alice, m1, m3, SuccNb)
]

rule Alice_0:
let
  m1 = senc(~Na, Kab)
in
[
  !Alice_init($Alice, Kab),
  Fr(~Na)
]--[
  Alice_0($Alice, Kab, ~Na, m1)
]->[
  Out($Alice),
  Out(m1),
  Alice_0($Alice, Kab, ~Na, m1)
]

rule Alice_1:
let
  <SuccNa, Nb> = sdec(m2, Kab)
  SuccNb = h(Nb)
  m3 = senc(SuccNb, Kab)
in
[
  Alice_0($Alice, Kab, Na, m1),
  In(m2)
]--[
  Alice_1($Alice, Kab, m2, <SuccNa, Nb>, SuccNb, m3),
  Eq(SuccNa, h(Na))
]->[
  Out(m3),
  Alice_1($Alice, Kab, m2, <SuccNa, Nb>, SuccNb, m3)
]

restriction Equality:
  "All x y #i. Eq(x,y) @i ==> x = y"

lemma executable:
exists-trace "
Ex Bob Kab Alice m1 m3 SuccNb m2 SuccNa Nb #t0 #t1.
Bob_2(Bob, Kab, Alice, m1, m3, SuccNb) @ #t0 &
Alice_1(Alice, Kab, m2, <SuccNa, Nb>, SuccNb, m3) @ #t1
"
end
