theory spthy
begin

builtins: symmetric-encryption, diffie-hellman

rule init:
let
  gb = 'g'^~b
  ga = 'g'^~a
in
[
  Fr(~a),
  Fr(~b),
  Fr(~instanceid),
  Fr(~secret)
]--[
  Principals(~instanceid, $Alice, $Bob)
]->[
  !Alice_init($Alice, ga, gb, ~instanceid, ~a, ~secret),
  !PrincipalPrivate($Alice, ~instanceid),
  !PrincipalPrivate($Alice, ~a),
  !PrincipalPrivate($Alice, ~secret),
  !Bob_init($Bob, gb, ga, ~instanceid, ~b),
  !PrincipalPrivate($Bob, ~instanceid),
  !PrincipalPrivate($Bob, ~b)
]

rule Alice_2_0:
let
  k = gb^a
  m = senc(secret, k)
in
[
  !Alice_init(Alice, ga, gb, instanceid, a, secret)
]--[
  Alice_2_0(Alice, ga, gb, instanceid, a, secret, k, m)
]->[
  Out(m),
  Alice_2_0(Alice, ga, gb, instanceid, a, secret, k, m)
]

rule Bob_2_1:
let
  k = ga^b
in
[
  !Bob_init(Bob, gb, ga, instanceid, b),
  In(senc(secret, 'g'^a^b))
]--[
  Bob_2_1(Bob, gb, ga, instanceid, b, senc(secret, 'g'^a^b), k, secret)
]->[
  Bob_2_1(Bob, gb, ga, instanceid, b, senc(secret, 'g'^a^b), k, secret)
]

rule privateReveal: [
  !PrincipalPrivate(Principal, Private)
]--[
  Dishonest(Principal)
]->[
  Out(Private)
]

lemma secrecy0:
all-traces "
All instanceid Alice Bob gb ga b m k secret #t0 #t1.
Principals(instanceid, Alice, Bob) @ #t0 &
not (Ex #t2.Dishonest(Alice) @ #t2) &
not (Ex #t3.Dishonest(Bob) @ #t3) &
Bob_2_1(Bob, gb, ga, instanceid, b, m, k, secret) @ #t1
==>
not (Ex #t4.K(secret) @ #t4)
"

end
