theory spthy
begin

builtins: symmetric-encryption, signing, hashing, diffie-hellman

rule init:
let
  gIKB = 'g'^~sIKB
  pIKB = pk(~sIKB)
in
[
  Fr(~instanceid),
  Fr(~sIKB),
  Fr(~sSPKB),
  Fr(~sIKA),
  Fr(~plaintext)
]--[
  Principals(~instanceid, $Alice, $Bob)
]->[
  !Alice_init($Alice, pIKB, gIKB, ~instanceid, ~sIKA, ~plaintext),
  !PrincipalPrivate($Alice, ~instanceid),
  !PrincipalPrivate($Alice, ~sIKA),
  !PrincipalPrivate($Alice, ~plaintext),
  !Bob_init($Bob, pIKB, gIKB, ~instanceid, ~sIKB, ~sSPKB),
  !PrincipalPrivate($Bob, ~instanceid),
  !PrincipalPrivate($Bob, ~sIKB),
  !PrincipalPrivate($Bob, ~sSPKB)
]

rule Alice_2_0:
let
  gIKA = 'g'^sIKA
  gEKA = 'g'^~sEKA
  DH1 = gSPKB^sIKA
  DH2 = gIKB^~sEKA
  DH3 = gSPKB^~sEKA
  DH4 = gOPKB^~sEKA
  SK = h(<DH1, DH2, DH3, DH4>)
  AD = <gIKA, gIKB>
  message = senc(plaintext, SK)
  MAC = h(<SK, plaintext, AD>)
in
[
  !Alice_init(Alice, pIKB, gIKB, instanceid, sIKA, plaintext),
  In(gSPKB),
  In(sigSPKB),
  In(gOPKB),
  Fr(~sEKA)
]--[
  Alice_2_0(Alice, pIKB, gIKB, instanceid, sIKA, plaintext, gSPKB, sigSPKB, gOPKB, gIKA, ~sEKA, gEKA, DH1, DH2, DH3, DH4, SK, AD, message, MAC),
  Eq(true, verify(sigSPKB, gSPKB, pIKB))
]->[
  Out(gIKA),
  Out(gEKA),
  Out(gOPKB),
  Out(message),
  Out(MAC),
  Alice_2_0(Alice, pIKB, gIKB, instanceid, sIKA, plaintext, gSPKB, sigSPKB, gOPKB, gIKA, ~sEKA, gEKA, DH1, DH2, DH3, DH4, SK, AD, message, MAC)
]

rule Bob_1_1:
let
  gSPKB = 'g'^sSPKB
  sigSPKB = sign(gSPKB, sIKB)
  gOPKB = 'g'^~sOPKB
in
[
  !Bob_init(Bob, pIKB, gIKB, instanceid, sIKB, sSPKB),
  Fr(~sOPKB)
]--[
  Bob_1_1(Bob, pIKB, gIKB, instanceid, sIKB, sSPKB, gSPKB, sigSPKB, ~sOPKB, gOPKB)
]->[
  Out(gSPKB),
  Out(sigSPKB),
  Out(gOPKB),
  Bob_1_1(Bob, pIKB, gIKB, instanceid, sIKB, sSPKB, gSPKB, sigSPKB, ~sOPKB, gOPKB)
]

rule Bob_3_4:
let
  DH1 = gIKA^sSPKB
  DH2 = gEKA^sIKB
  DH3 = gEKA^sSPKB
  DH4 = gEKA^sOPKB
  SK = h(<DH1, DH2, DH3, DH4>)
  AD = <gIKA, gIKB>
in
[
  Bob_1_1(Bob, pIKB, gIKB, instanceid, sIKB, sSPKB, gSPKB, sigSPKB, sOPKB, gOPKB),
  In(gIKA),
  In(gEKA),
  In(gOPKB),
  In(senc(plaintext, SK)),
  In(MAC)
]--[
  Bob_3_4(Bob, pIKB, gIKB, instanceid, sIKB, sSPKB, gIKA, gEKA, gOPKB, senc(plaintext, SK), MAC, DH1, DH2, DH3, DH4, SK, AD, plaintext),
  Eq(MAC, h(<SK, plaintext, AD>))
]->[
  Bob_3_4(Bob, pIKB, gIKB, instanceid, sIKB, sSPKB, gIKA, gEKA, gOPKB, senc(plaintext, SK), MAC, DH1, DH2, DH3, DH4, SK, AD, plaintext)
]

rule privateReveal: [
  !PrincipalPrivate(Principal, Private)
]--[
  Dishonest(Principal)
]->[
  Out(Private)
]

restriction Equality:
  "All x y #i. Eq(x,y) @i ==> x = y"

lemma secrecy0:
all-traces "
All instanceid Alice Bob pIKB gIKB sIKB sSPKB gIKA gEKA gOPKB message MAC DH1 DH2 DH3 DH4 SK AD plaintext #t0 #t1.
Principals(instanceid, Alice, Bob) @ #t0 &
not (Ex #t2.Dishonest(Alice) @ #t2) &
not (Ex #t3.Dishonest(Bob) @ #t3) &
Bob_3_4(Bob, pIKB, gIKB, instanceid, sIKB, sSPKB, gIKA, gEKA, gOPKB, message, MAC, DH1, DH2, DH3, DH4, SK, AD, plaintext) @ #t1
==>
not (Ex #t4.K(plaintext) @ #t4)
"

end
