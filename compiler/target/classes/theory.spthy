theory spthy
begin

builtins: symmetric-encryption, hashing

rule init:
[
  Fr(~Kab)
]-->[
  !Bob_init($Bob, ~Kab),
  !Alice_init($Alice, ~Kab)
]

rule Bob_1_0:
let
  SuccNa = h(Na)
  m2 = senc(<SuccNa, ~Nb>, Kab)
in
[
  !Bob_init($Bob, Kab),
  In($Alice),
  In(senc(Na, Kab)),
  Fr(~Nb)
]--[
  Bob_1_0($Bob, Kab, $Alice, senc(Na, Kab), Na, SuccNa, ~Nb, m2)
]->[
  Out(m2),
  Bob_1_0($Bob, Kab, $Alice, senc(Na, Kab), Na, SuccNa, ~Nb, m2)
]

rule Bob_3_4:
[
  Bob_1_0($Bob, Kab, $Alice, m1, Na, SuccNa, Nb, m2),
  In(senc(SuccNb, Kab))
]--[
  Bob_3_4($Bob, Kab, $Alice, m1, senc(SuccNb, Kab), SuccNb),
  Eq(SuccNb, h(Nb))
]->[
  Bob_3_4($Bob, Kab, $Alice, m1, senc(SuccNb, Kab), SuccNb)
]

rule Alice_0_2:
let
  m1 = senc(~Na, Kab)
in
[
  !Alice_init($Alice, Kab),
  Fr(~Na)
]--[
  Alice_0_2($Alice, Kab, ~Na, m1)
]->[
  Out($Alice),
  Out(m1),
  Alice_0_2($Alice, Kab, ~Na, m1)
]

rule Alice_2_3:
let
  SuccNb = h(Nb)
  m3 = senc(SuccNb, Kab)
in
[
  Alice_0_2($Alice, Kab, Na, m1),
  In(senc(<SuccNa, Nb>, Kab))
]--[
  Alice_2_3($Alice, Kab, senc(<SuccNa, Nb>, Kab), <SuccNa, Nb>, SuccNb, m3),
  Eq(SuccNa, h(Na))
]->[
  Out(m3),
  Alice_2_3($Alice, Kab, senc(<SuccNa, Nb>, Kab), <SuccNa, Nb>, SuccNb, m3)
]

restriction Equality:
  "All x y #i. Eq(x,y) @i ==> x = y"

lemma executable:
exists-trace "
Ex Bob Kab Alice m1 m3 SuccNb m2 SuccNa Nb #t0 #t1.
Bob_3_4(Bob, Kab, Alice, m1, m3, SuccNb) @ #t0 &
Alice_2_3(Alice, Kab, m2, <SuccNa, Nb>, SuccNb, m3) @ #t1
"
end
