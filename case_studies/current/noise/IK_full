// notation: 
// key XYZ; X: Static/Ephemeral, Y: Secret/Public, Z: Alice/Bob
// temp_k = tk
// we ignore deterministic steps depening only on protocol_name or prologue
//   instead we set ck0 to the constant 'ck0'
// we represent an AEAD scheme as MAC + encyrption
//   we name messages M and suffix them with lowercase content
//   we prefix it with "mac" if it is the MAC of the message
// we represent the outputs of HKDF(ck, input, 2) as
//   output1 = HASH({ HASH({ck, input}) , '1' })
//   output2 = HASH({ HASH({ck, input}) , output1, '2' })

// PATTERN: IK

principals: Alice, Bob

// premessage "<- s"
// Bob has distributed his static key
Bob [
  knows private SSB
  distributed SPB = 'g'^SSB
]

// initialization for Alice
// local static (s) is {SSA, SPA}
// remote static (rs) is SPB   
Alice [
  knows private SSA
  SPA = 'g'^SSA
  knows public SPB
  // handshake pattern is IK
  // initiator is Alice
  // MixHash(s)
  h0 = HASH(SPB)
  ck0 = 'ck0'
]

// send -> e, es, s, ss
Alice [
  // "e"; e = {ESA, EPA}
  generates ESA
  EPA = 'g'^ESA
  h1 = HASH({h0, EPA})
  // "es"
  DHes = SPB^ESA
  ck1 = HASH({HASH({ck0, DHes}), '1'})
  k1 = HASH({HASH({ck0, DHes}), ck1, '2'})
  // "s"
  Mspa = ENC(HASH({k1, h1}), SPA)
  macMspa = HASH({k1, h1, SPA})
  h2 = HASH({h1, Mspa})
  // "ss"
  DHss = SPB^SSA
  ck2 = HASH({HASH({ck1, DHss}), '1'})
  k2 = HASH({HASH({ck1, DHss}), ck2, '2'})

  // EncryptAndHash(payload1)
  generates payload1
  M1 = ENC(HASH({k2, h2}), payload1)
  macM1 = HASH({k2, h2, payload1})
]
Alice -> Bob: EPA, {Mspa, macMspa}, {M1, macM1}

// initialization for Bob
// local static (s) is {SSB, SPB}
Bob [
  // MixHash(s)
  h0 = HASH(SPB)
  ck0 = 'ck0'
]

// receiving -> e, es, s, ss
Bob [
  // "e"; re = EPA
  h1 = HASH({h0, EPA})
  // "es"
  DHes = EPA^SSB
  ck1 = HASH({HASH({ck0, DHes}), '1'})
  k1 = HASH({HASH({ck0, DHes}), ck1, '2'})
  // "s"
  SPA = DEC(HASH({k1, h1}), Mspa)
  EQUALS(macMspa, HASH({k1, h1, SPA}))?
  h2 = HASH({h1, Mspa})
  // "ss"
  DHss = SPA^SSB
  ck2 = HASH({HASH({ck1, DHss}), '1'})
  k2 = HASH({HASH({ck1, DHss}), ck2, '2'})

  // DecryptAndHash(M1)
  payload1 = DEC(HASH({k2, h2}), M1)
  EQUALS(macM1, HASH({k2, h2, payload1}))?
]

// sending <- e, ee, se
Bob [
  // "e"; e = {ESB, EPB}
  generates ESB
  EPB = 'g'^ESB
  h3 = HASH({h0, EPB})
  // "ee"
  DHee = EPA^ESB
  ck3 = HASH({HASH({ck2, DHee}), '1'})
  k3 = HASH({HASH({ck2, DHee}), ck3, '2'})
  // "se"
  DHse = SPA^ESB
  ck4 = HASH({HASH({ck3, DHse}), '1'})
  k4 = HASH({HASH({ck3, DHse}), ck4, '2'})
]
Bob -> Alice: EPB

// receiving <- e, ee, se
Alice [
  // "e"; re = EPB
  h3 = HASH({h0, EPB})
  // "ee"
  DHee = EPB^ESA
  ck3 = HASH({HASH({ck2, DHee}), '1'})
  k3 = HASH({HASH({ck2, DHee}), ck3, '2'})
  // "se"
  DHse = EPB^SSA
  ck4 = HASH({HASH({ck3, DHse}), '1'})
  k4 = HASH({HASH({ck3, DHse}), ck4, '2'})
]

// send proper payload
Alice [
  // EncryptAndHash(payload2)
  generates payload2
  M2 = ENC(HASH({k4, h2}), payload2)
  macM2 = HASH({k4, h2, payload2})
]
Alice -> Bob: {M2, macM2}

Bob [
  // DecryptAndHash(M2)
  payload2 = DEC(HASH({k4, h2}), M2)
  EQUALS(macM2, HASH({k4, h2, payload2}))?
]

queries [
  forward-secrecy? Alice's payload2
]